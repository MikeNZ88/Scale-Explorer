let api = null;
let isPlayerReady = false;
let trackStates = {}; // Store track states (visible, muted, solo)

// DOM elements
const fileInput = document.getElementById('fileInput');
const fileInputContainer = document.getElementById('fileInputContainer');
const fileNameDisplay = document.getElementById('fileNameDisplay');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const volumeSlider = document.getElementById('volumeSlider');
const volumeValue = document.getElementById('volumeValue');
const speedSlider = document.getElementById('speedSlider');
const speedValue = document.getElementById('speedValue');
const trackInfo = document.getElementById('trackInfo');
const trackControls = document.querySelector('.track-controls');
const tracksGrid = document.getElementById('tracksGrid');
const songTitle = document.getElementById('songTitle');
const songArtist = document.getElementById('songArtist');
const trackCount = document.getElementById('trackCount');
const horizontalControls = document.getElementById('horizontalControls');

// Track control buttons
const showAllTracks = document.getElementById('showAllTracks');
const hideAllTracks = document.getElementById('hideAllTracks');
const unmuteAllTracks = document.getElementById('unmuteAllTracks');
const unsoloAllTracks = document.getElementById('unsoloAllTracks');

// Initialize AlphaTab
function initializeAlphaTab() {
    try {
        console.log('Initializing AlphaTab...');
        
        // Check if AlphaTab is loaded
        if (typeof alphaTab === 'undefined') {
            console.error('AlphaTab library not loaded!');
            return;
        }
        
        // Get the container element
        const container = document.getElementById('alphaTab');
        if (!container) {
            console.error('AlphaTab container not found!');
            return;
        }
        
        console.log('Container found:', container);
        
        const settings = {
            player: {
                enablePlayer: true,
                soundFont: 'https://cdn.jsdelivr.net/npm/@coderline/alphatab@latest/dist/soundfont/sonivox.sf2',
                scrollElement: window,
                enableCursor: true,
                enableUserInteraction: true,
                enableAnimatedBeatCursor: true
            },
            display: {
                scale: 1.0,
                stretchForce: 1.0,
                layoutMode: 'page',
                staveProfile: 'default',
                resources: {
                    copyrightFont: 'bold 12px Arial',
                    titleFont: '32px serif',
                    subTitleFont: '20px serif',
                    wordsFont: '15px serif',
                    mainGlyphColor: '#000000',
                    secondaryGlyphColor: '#000000',
                    scoreInfoColor: '#000000',
                    staffLineColor: '#000000',
                    barSeparatorColor: '#000000',
                    tablatureColor: '#0066CC'
                }
            },
            core: {
                fontDirectory: 'https://cdn.jsdelivr.net/npm/@coderline/alphatab@latest/dist/font/',
                engine: 'html5',
                enableLazyLoading: false, // Disable lazy loading to ensure all content is rendered immediately
                tracks: [-1] // -1 means render all tracks by default
            }
        };
        
        console.log('Creating AlphaTab API with settings:', settings);
        api = new alphaTab.AlphaTabApi(container, settings);
        console.log('AlphaTab API created:', api);
        
        // Event listeners
        api.scoreLoaded.on((score) => {
            console.log('Score loaded successfully:', score.title, 'Tracks:', score.tracks.length);
            isRenderingComplete = false; // Reset rendering flag for new score
            updateTrackInfo(score);
            updateScoreForExport(score);
            enablePlayerControls(true);
            // Don't call track control functions here - let AlphaTab render all tracks by default
        });
        
        api.renderStarted.on(() => {
            console.log('Rendering started...');
        });
        
        api.renderFinished.on(() => {
            console.log('Rendering finished - tab should be visible');
            isRenderingComplete = true;
            // Force a layout update
            setTimeout(() => {
                if (api && api.container) {
                    console.log('Container dimensions:', {
                        width: api.container.offsetWidth,
                        height: api.container.offsetHeight,
                        scrollHeight: api.container.scrollHeight
                    });
                }
            }, 100);
        });
        
        api.playerReady.on(() => {
            console.log('Player ready');
            isPlayerReady = true;
        });
        
        api.playerStateChanged.on((e) => {
            console.log('Player state changed:', e.state);
            updatePlayerButtons(e.state);
        });
        
        // Add click-to-seek functionality
        api.beatMouseDown.on((beat) => {
            if (api && beat) {
                try {
                    console.log('Beat clicked, seeking to:', beat.absolutePlaybackStart);
                    // Set playback position to the clicked beat
                    api.tickPosition = beat.absolutePlaybackStart;
                } catch (error) {
                    console.error('Error seeking to position:', error);
                }
            }
        });
        
        // Add playback cursor functionality
        api.playerPositionChanged.on((e) => {
            // The cursor position is automatically handled by AlphaTab
            // This event fires when the playback position changes
        });
        
        api.error.on((error) => {
            console.error('AlphaTab Error:', error);
        });
        
        console.log('AlphaTab initialization complete');
        
    } catch (error) {
        console.error('Initialization error:', error);
    }
}

// Load file from input
function loadFile(file) {
    if (!api) {
        return;
    }
    
    try {
        console.log('File details:', {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: new Date(file.lastModified)
        });
        
        // Read file as ArrayBuffer for better debugging
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const arrayBuffer = e.target.result;
                console.log('File loaded as ArrayBuffer, size:', arrayBuffer.byteLength);
                
                // Check file header for GP files
                const headerView = new Uint8Array(arrayBuffer, 0, Math.min(50, arrayBuffer.byteLength));
                const headerString = String.fromCharCode.apply(null, headerView);
                console.log('File header (first 50 bytes):', headerString);
                
                api.load(arrayBuffer);
            } catch (loadError) {
                console.error('Error loading file into player:', loadError);
            }
        };
        reader.onerror = function() {
            console.error('Failed to read file');
        };
        reader.readAsArrayBuffer(file);
        
    } catch (error) {
        console.error('Load error:', error);
    }
}

// Update track info display
function updateTrackInfo(score) {
    // Enhanced metadata extraction
    const metadata = extractComprehensiveMetadata(score);
    
    songTitle.textContent = metadata.title;
    songArtist.textContent = metadata.artist;
    trackCount.textContent = `Tracks: ${score.tracks.length}`;
    
    // Log all available metadata for debugging
    console.log('Complete score metadata:', {
        title: score.title,
        artist: score.artist,
        album: score.album,
        words: score.words,
        music: score.music,
        copyright: score.copyright,
        tab: score.tab,
        instructions: score.instructions,
        notices: score.notices,
        masterVolume: score.masterVolume,
        tempo: score.tempo
    });
    
    // Initialize track controls but don't interfere with initial rendering
    initializeTrackStates(score);
    createTrackControls(score);
    
    trackInfo.style.display = 'block';
}

// Extract comprehensive metadata from Guitar Pro file
function extractComprehensiveMetadata(score) {
    let title = 'Unknown Title';
    let artist = 'Unknown Artist';
    
    // Extract title
    if (score.title && score.title.trim()) {
        title = score.title.trim();
    }
    
    // Extract artist information with multiple sources
    const artistInfo = [];
    
    // Check for composer/music information
    if (score.music && score.music.trim()) {
        artistInfo.push(`Music: ${score.music.trim()}`);
    }
    
    // Check for lyricist/words information
    if (score.words && score.words.trim()) {
        artistInfo.push(`Words: ${score.words.trim()}`);
    }
    
    // Check for arranger information
    if (score.artist && score.artist.trim()) {
        artistInfo.push(`Arranged: ${score.artist.trim()}`);
    }
    
    // Check for copyright information
    if (score.copyright && score.copyright.trim()) {
        artistInfo.push(`Â© ${score.copyright.trim()}`);
    }
    
    // Check for tab information (often contains arranger info)
    if (score.tab && score.tab.trim()) {
        artistInfo.push(`Tab: ${score.tab.trim()}`);
    }
    
    // If we have detailed info, use it; otherwise fall back to basic artist
    if (artistInfo.length > 0) {
        artist = artistInfo.join(' | ');
    } else if (score.artist && score.artist.trim()) {
        artist = score.artist.trim();
    }
    
    return { title, artist };
}

// Enable/disable player controls
function enablePlayerControls(enabled) {
    playBtn.disabled = !enabled;
    pauseBtn.disabled = !enabled;
    stopBtn.disabled = !enabled;
    horizontalControls.style.display = enabled ? 'flex' : 'none';
}

// Update player button states
function updatePlayerButtons(state) {
    const isPlaying = state === 1; // PlayerState.Playing
    const isPaused = state === 2;  // PlayerState.Paused
    
    playBtn.disabled = isPlaying;
    pauseBtn.disabled = !isPlaying;
    stopBtn.disabled = state === 0; // PlayerState.Paused
}

// Track control functions
function initializeTrackStates(score) {
    trackStates = {};
    score.tracks.forEach((track, index) => {
        trackStates[index] = {
            visible: true,
            muted: false,
            solo: false
        };
    });
}

function createTrackControls(score) {
    tracksGrid.innerHTML = '';
    
    score.tracks.forEach((track, index) => {
        const trackItem = document.createElement('div');
        trackItem.className = 'track-item';
        trackItem.setAttribute('data-track-index', index);
        
        // Enhanced track name detection with multiple fallbacks
        const trackName = getTrackName(track, index);
        
        // Enhanced instrument detection with multiple fallbacks
        const instrumentInfo = getInstrumentInfo(track, index);
        
        trackItem.innerHTML = `
            <div class="track-header">
                <div class="track-name">${trackName}</div>
            </div>
            <div class="track-info-details">
                ${instrumentInfo}
            </div>
            <div class="track-controls-buttons">
                <button class="track-btn visibility visible" data-action="visibility" data-track="${index}">
                    Show
                </button>
                <button class="track-btn solo" data-action="solo" data-track="${index}">
                    Solo
                </button>
                <button class="track-btn mute" data-action="mute" data-track="${index}">
                    Mute
                </button>
            </div>
        `;
        
        tracksGrid.appendChild(trackItem);
    });
    
    // Add event listeners to track buttons
    tracksGrid.addEventListener('click', handleTrackButtonClick);
    
    trackControls.style.display = 'block';
}

function handleTrackButtonClick(event) {
    if (!event.target.classList.contains('track-btn')) return;
    
    const action = event.target.getAttribute('data-action');
    const trackIndex = parseInt(event.target.getAttribute('data-track'));
    
    switch (action) {
        case 'visibility':
            toggleTrackVisibility(trackIndex);
            break;
        case 'solo':
            toggleTrackSolo(trackIndex);
            break;
        case 'mute':
            toggleTrackMute(trackIndex);
            break;
    }
}

function toggleTrackVisibility(trackIndex) {
    const state = trackStates[trackIndex];
    state.visible = !state.visible;
    
    // Update AlphaTab track visibility using the correct API
    if (api && api.score) {
        // Get all visible track indexes
        const visibleTracks = Object.keys(trackStates)
            .map(index => parseInt(index))
            .filter(index => trackStates[index].visible);
        
        if (visibleTracks.length > 0) {
            // Use renderScore with track indexes (not renderTracks)
            api.renderScore(api.score, visibleTracks);
        } else {
            // If no tracks would be visible, keep this one visible
            state.visible = true;
            api.renderScore(api.score, [trackIndex]);
        }
    }
    
    updateTrackUI(trackIndex);
}

function toggleTrackSolo(trackIndex) {
    const state = trackStates[trackIndex];
    state.solo = !state.solo;
    
    // If soloing this track, unmute it
    if (state.solo) {
        state.muted = false;
    }
    
    // Update audio playback
    updateAudioPlayback();
    updateTrackUI(trackIndex);
}

function toggleTrackMute(trackIndex) {
    const state = trackStates[trackIndex];
    state.muted = !state.muted;
    
    // If muting this track, unsolo it
    if (state.muted) {
        state.solo = false;
    }
    
    // Update audio playback
    updateAudioPlayback();
    updateTrackUI(trackIndex);
}

function updateAudioPlayback() {
    if (!api || !isPlayerReady) return;
    
    // Check if any tracks are soloed
    const soloedTracks = Object.keys(trackStates).filter(index => trackStates[index].solo);
    
    Object.keys(trackStates).forEach(index => {
        const trackIndex = parseInt(index);
        const state = trackStates[trackIndex];
        
        if (soloedTracks.length > 0) {
            // If there are soloed tracks, only play soloed tracks
            api.changeTrackVolume([trackIndex], state.solo ? 1 : 0);
        } else {
            // If no tracks are soloed, respect mute settings
            api.changeTrackVolume([trackIndex], state.muted ? 0 : 1);
        }
    });
}

function updateTrackUI(trackIndex) {
    const trackItem = document.querySelector(`[data-track-index="${trackIndex}"]`);
    if (!trackItem) return;
    
    const state = trackStates[trackIndex];
    const visibilityBtn = trackItem.querySelector('[data-action="visibility"]');
    const soloBtn = trackItem.querySelector('[data-action="solo"]');
    const muteBtn = trackItem.querySelector('[data-action="mute"]');
    
    // Update visibility button
    if (state.visible) {
        visibilityBtn.classList.add('visible');
        visibilityBtn.textContent = 'Hide';
    } else {
        visibilityBtn.classList.remove('visible');
        visibilityBtn.textContent = 'Show';
    }
    
    // Update solo button
    if (state.solo) {
        soloBtn.classList.add('active');
        soloBtn.textContent = 'Solo';
    } else {
        soloBtn.classList.remove('active');
        soloBtn.textContent = 'Solo';
    }
    
    // Update mute button
    if (state.muted) {
        muteBtn.classList.add('active');
        muteBtn.textContent = 'Muted';
    } else {
        muteBtn.classList.remove('active');
        muteBtn.textContent = 'Mute';
    }
    
    // Update track item appearance
    trackItem.classList.toggle('muted', state.muted);
    trackItem.classList.toggle('solo', state.solo);
}

// Bulk track control functions
function showAllTracksFunction() {
    Object.keys(trackStates).forEach(index => {
        const trackIndex = parseInt(index);
        trackStates[trackIndex].visible = true;
        updateTrackUI(trackIndex);
    });
    
    // Render all tracks using renderScore
    if (api && api.score) {
        const allTracks = Object.keys(trackStates).map(index => parseInt(index));
        api.renderScore(api.score, allTracks);
    }
}

function hideAllTracksFunction() {
    // Don't allow hiding all tracks - keep at least one visible
    const trackIndices = Object.keys(trackStates).map(index => parseInt(index));
    if (trackIndices.length === 0) return;
    
    // Hide all except the first track
    trackIndices.forEach((trackIndex, i) => {
        trackStates[trackIndex].visible = i === 0;
        updateTrackUI(trackIndex);
    });
    
    // Render only the first track using renderScore
    if (api && api.score) {
        api.renderScore(api.score, [trackIndices[0]]);
    }
}

function unmuteAllTracksFunction() {
    Object.keys(trackStates).forEach(index => {
        const trackIndex = parseInt(index);
        trackStates[trackIndex].muted = false;
        updateTrackUI(trackIndex);
    });
    updateAudioPlayback();
}

function unsoloAllTracksFunction() {
    Object.keys(trackStates).forEach(index => {
        const trackIndex = parseInt(index);
        trackStates[trackIndex].solo = false;
        updateTrackUI(trackIndex);
    });
    updateAudioPlayback();
}

// Update file input display
function updateFileInputDisplay(fileName) {
    const fileInputText = document.querySelector('.file-input-text');
    const fileInputIcon = document.querySelector('.file-input-icon');
    
    if (fileName) {
        fileInputContainer.classList.add('has-file');
        fileInputText.textContent = 'File Selected';
        fileInputIcon.textContent = 'âœ…';
        fileNameDisplay.textContent = fileName;
        fileNameDisplay.style.display = 'block';
    } else {
        fileInputContainer.classList.remove('has-file');
        fileInputText.textContent = 'Choose Guitar Pro File';
        fileInputIcon.textContent = 'ðŸ“';
        fileNameDisplay.style.display = 'none';
    }
}

// Event listeners setup
function setupEventListeners() {
    // File input
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            updateFileInputDisplay(file.name);
            loadFile(file);
        } else {
            updateFileInputDisplay(null);
        }
    });
    
    // Player controls
    playBtn.addEventListener('click', () => {
        if (api && isPlayerReady) {
            api.playPause();
        }
    });
    
    pauseBtn.addEventListener('click', () => {
        if (api && isPlayerReady) {
            api.playPause();
        }
    });
    
    stopBtn.addEventListener('click', () => {
        if (api && isPlayerReady) {
            api.stop();
        }
    });
    
    // Volume control
    volumeSlider.addEventListener('input', (e) => {
        const volume = parseFloat(e.target.value) / 100; // Convert percentage to decimal
        volumeValue.textContent = `${e.target.value}%`;
        if (api && isPlayerReady) {
            api.masterVolume = volume;
        }
    });
    
    // Speed control
    speedSlider.addEventListener('input', (e) => {
        const speed = parseFloat(e.target.value) / 100; // Convert percentage to decimal
        speedValue.textContent = `${e.target.value}%`;
        if (api && isPlayerReady) {
            api.playbackSpeed = speed;
        }
    });
    
    // Speed slider double-click to reset to 100%
    speedSlider.addEventListener('dblclick', () => {
        speedSlider.value = 100;
        speedValue.textContent = '100%';
        if (api && isPlayerReady) {
            api.playbackSpeed = 1.0;
        }
    });
    
    // Bulk track control event listeners
    showAllTracks.addEventListener('click', showAllTracksFunction);
    hideAllTracks.addEventListener('click', hideAllTracksFunction);
    unmuteAllTracks.addEventListener('click', unmuteAllTracksFunction);
    unsoloAllTracks.addEventListener('click', unsoloAllTracksFunction);
    
    // Global keyboard controls
    document.addEventListener('keydown', (e) => {
        // Spacebar for play/pause
        if (e.code === 'Space') {
            // Only prevent spacebar if not typing in input fields
            const activeElement = document.activeElement;
            const isTyping = activeElement && activeElement.matches('input[type="text"], input[type="search"], textarea');
            
            // Allow spacebar to work everywhere except when typing
            if (!isTyping && api && isPlayerReady) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Spacebar triggered play/pause');
                api.playPause();
            }
        }
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    initializeAlphaTab();
    setupEventListeners();
    initializePngExport();
    initializeBarSelection();
    
    // Force hide modal on page load to prevent it from being stuck open
    forceHideModal();
});

// Bar Selection System
let barSelectionState = {
    isEnabled: false,
    startBar: null,
    endBar: null,
    currentSelection: null,
    isLooping: false,
    selectionBounds: null
};

// Bar Selection DOM Elements
const barSelectionSection = document.getElementById('barSelectionSection');
const selectionModeBtn = document.getElementById('selectionModeBtn');
const selectionStartBar = document.getElementById('selectionStartBar');
const selectionEndBar = document.getElementById('selectionEndBar');
const applySelectionBtn = document.getElementById('applySelectionBtn');
const clearSelectionBtn = document.getElementById('clearSelectionBtn');
const selectedRangeDisplay = document.getElementById('selectedRangeDisplay');
const loopStatusDisplay = document.getElementById('loopStatusDisplay');
const exportReadyDisplay = document.getElementById('exportReadyDisplay');
const enableLoopBtn = document.getElementById('enableLoopBtn');
const disableLoopBtn = document.getElementById('disableLoopBtn');
const exportSelectionBtn = document.getElementById('exportSelectionBtn');
const captureSelectionBtn = document.getElementById('captureSelectionBtn');

// Initialize Bar Selection System
function initializeBarSelection() {
    console.log('ðŸŽ¯ Initializing Bar Selection System...');
    
    // Event listeners for bar selection
    selectionModeBtn.addEventListener('click', toggleSelectionMode);
    selectionStartBar.addEventListener('change', updateSelectionPreview);
    selectionEndBar.addEventListener('change', updateSelectionPreview);
    applySelectionBtn.addEventListener('click', applyBarSelection);
    clearSelectionBtn.addEventListener('click', clearBarSelection);
    enableLoopBtn.addEventListener('click', enablePlaybackLoop);
    disableLoopBtn.addEventListener('click', disablePlaybackLoop);
    exportSelectionBtn.addEventListener('click', exportSelectedBars);
    captureSelectionBtn.addEventListener('click', captureSelectedArea);
    
    // Ensure end bar is always >= start bar
    selectionStartBar.addEventListener('change', () => {
        const startBar = parseInt(selectionStartBar.value);
        const endBar = parseInt(selectionEndBar.value);
        if (endBar < startBar) {
            selectionEndBar.value = startBar;
            updateSelectionPreview();
        }
    });
    
    selectionEndBar.addEventListener('change', () => {
        const startBar = parseInt(selectionStartBar.value);
        const endBar = parseInt(selectionEndBar.value);
        if (endBar < startBar) {
            selectionStartBar.value = endBar;
            updateSelectionPreview();
        }
    });
    
    console.log('âœ… Bar Selection System initialized');
}

// Toggle selection mode
function toggleSelectionMode() {
    barSelectionState.isEnabled = !barSelectionState.isEnabled;
    
    const modeBtn = selectionModeBtn;
    const modeText = modeBtn.querySelector('.mode-text');
    
    if (barSelectionState.isEnabled) {
        modeBtn.setAttribute('data-mode', 'on');
        modeText.textContent = 'Disable Selection';
        enableSelectionControls(true);
        console.log('ðŸŽ¯ Bar selection mode enabled');
    } else {
        modeBtn.setAttribute('data-mode', 'off');
        modeText.textContent = 'Enable Selection';
        enableSelectionControls(false);
        clearBarSelection();
        console.log('ðŸŽ¯ Bar selection mode disabled');
    }
}

// Enable/disable selection controls
function enableSelectionControls(enabled) {
    selectionStartBar.disabled = !enabled;
    selectionEndBar.disabled = !enabled;
    applySelectionBtn.disabled = !enabled;
    
    if (enabled) {
        updateSelectionPreview();
    } else {
        selectedRangeDisplay.textContent = 'None';
        selectedRangeDisplay.className = 'info-value';
    }
}

// Update selection preview
function updateSelectionPreview() {
    if (!barSelectionState.isEnabled) return;
    
    const startBar = parseInt(selectionStartBar.value);
    const endBar = parseInt(selectionEndBar.value);
    
    if (startBar && endBar) {
        if (startBar === endBar) {
            selectedRangeDisplay.textContent = `Bar ${startBar}`;
        } else {
            selectedRangeDisplay.textContent = `Bars ${startBar}-${endBar}`;
        }
        selectedRangeDisplay.className = 'info-value warning';
        applySelectionBtn.disabled = false;
    } else {
        selectedRangeDisplay.textContent = 'Invalid Range';
        selectedRangeDisplay.className = 'info-value';
        applySelectionBtn.disabled = true;
    }
}

// Apply bar selection using AlphaTab's built-in selection system
function applyBarSelection() {
    if (!api || !currentScore || !barSelectionState.isEnabled) {
        console.warn('âš ï¸ Cannot apply selection: API, score, or selection mode not ready');
        return;
    }
    
    const startBar = parseInt(selectionStartBar.value) - 1; // Convert to 0-based
    const endBar = parseInt(selectionEndBar.value) - 1;     // Convert to 0-based
    
    console.log(`ðŸŽ¯ Applying bar selection: ${startBar + 1} to ${endBar + 1}`);
    
    try {
        // Store selection state
        barSelectionState.startBar = startBar;
        barSelectionState.endBar = endBar;
        
        // Get the bounds for the selected bars
        const selectionBounds = getBarRangeBounds(startBar, endBar);
        if (selectionBounds) {
            barSelectionState.selectionBounds = selectionBounds;
            
            // Create visual selection using AlphaTab's selection system
            createVisualSelection(selectionBounds);
            
            // Update UI
            updateSelectionUI();
            
            console.log('âœ… Bar selection applied successfully');
            console.log('ðŸ“Š Selection bounds:', selectionBounds);
        } else {
            throw new Error('Could not determine bar bounds');
        }
        
    } catch (error) {
        console.error('âŒ Failed to apply bar selection:', error);
        alert('Failed to apply bar selection. Please ensure the score is fully loaded.');
    }
}

// Get bounds for a range of bars
function getBarRangeBounds(startBar, endBar) {
    if (!api || !api.boundsLookup || !api.boundsLookup.isFinished) {
        console.warn('âš ï¸ Bounds lookup not available or not finished');
        return null;
    }
    
    const boundsLookup = api.boundsLookup;
    const bounds = [];
    
    // Collect bounds for all bars in range
    for (let barIndex = startBar; barIndex <= endBar; barIndex++) {
        const barBounds = boundsLookup.findMasterBarByIndex(barIndex);
        if (barBounds) {
            bounds.push({
                barIndex: barIndex,
                bounds: barBounds
            });
        }
    }
    
    if (bounds.length === 0) {
        console.warn(`âš ï¸ No bounds found for bars ${startBar + 1}-${endBar + 1}`);
        return null;
    }
    
    // Group by staff system and calculate overall bounds
    const systemBounds = new Map();
    
    bounds.forEach(bar => {
        const systemIndex = bar.bounds.staffSystemBounds.index;
        if (!systemBounds.has(systemIndex)) {
            systemBounds.set(systemIndex, []);
        }
        systemBounds.get(systemIndex).push(bar);
    });
    
    // Calculate bounding rectangles for each system
    const selectionRects = [];
    let totalBounds = null;
    
    for (const [systemIndex, systemBars] of systemBounds) {
        systemBars.sort((a, b) => a.bounds.realBounds.x - b.bounds.realBounds.x);
        
        const firstBar = systemBars[0];
        const lastBar = systemBars[systemBars.length - 1];
        
        const rect = {
            x: firstBar.bounds.realBounds.x,
            y: firstBar.bounds.staffSystemBounds.realBounds.y,
            width: (lastBar.bounds.realBounds.x + lastBar.bounds.realBounds.w) - firstBar.bounds.realBounds.x,
            height: firstBar.bounds.staffSystemBounds.realBounds.h,
            systemIndex: systemIndex
        };
        
        selectionRects.push(rect);
        
        // Calculate total bounds
        if (!totalBounds) {
            totalBounds = { ...rect };
        } else {
            totalBounds.x = Math.min(totalBounds.x, rect.x);
            totalBounds.y = Math.min(totalBounds.y, rect.y);
            totalBounds.width = Math.max(totalBounds.x + totalBounds.width, rect.x + rect.width) - totalBounds.x;
            totalBounds.height = Math.max(totalBounds.y + totalBounds.height, rect.y + rect.height) - totalBounds.y;
        }
    }
    
    return {
        startBar: startBar,
        endBar: endBar,
        rects: selectionRects,
        totalBounds: totalBounds,
        barCount: endBar - startBar + 1
    };
}

// Create visual selection overlay
function createVisualSelection(selectionBounds) {
    // Remove existing selection overlay
    removeVisualSelection();
    
    const alphaTabContainer = document.getElementById('alphaTab');
    if (!alphaTabContainer) return;
    
    // Create overlay container
    const overlay = document.createElement('div');
    overlay.className = 'bar-selection-overlay';
    overlay.id = 'barSelectionOverlay';
    
    // Create selection rectangles
    selectionBounds.rects.forEach((rect, index) => {
        const selectionRect = document.createElement('div');
        selectionRect.className = 'selection-highlight';
        selectionRect.style.position = 'absolute';
        selectionRect.style.left = `${rect.x}px`;
        selectionRect.style.top = `${rect.y}px`;
        selectionRect.style.width = `${rect.width}px`;
        selectionRect.style.height = `${rect.height}px`;
        
        overlay.appendChild(selectionRect);
    });
    
    // Position overlay relative to AlphaTab container
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.pointerEvents = 'none';
    overlay.style.zIndex = '100';
    
    // Add to container
    alphaTabContainer.style.position = 'relative';
    alphaTabContainer.appendChild(overlay);
    
    console.log('âœ… Visual selection overlay created');
}

// Remove visual selection overlay
function removeVisualSelection() {
    const existingOverlay = document.getElementById('barSelectionOverlay');
    if (existingOverlay) {
        existingOverlay.remove();
        console.log('ðŸ—‘ï¸ Visual selection overlay removed');
    }
}

// Update selection UI displays
function updateSelectionUI() {
    const { startBar, endBar, isLooping } = barSelectionState;
    
    if (startBar !== null && endBar !== null) {
        // Update range display
        if (startBar === endBar) {
            selectedRangeDisplay.textContent = `Bar ${startBar + 1}`;
        } else {
            selectedRangeDisplay.textContent = `Bars ${startBar + 1}-${endBar + 1}`;
        }
        selectedRangeDisplay.className = 'info-value active';
        
        // Update export ready status
        exportReadyDisplay.textContent = 'Yes';
        exportReadyDisplay.className = 'info-value active';
        
        // Enable action buttons
        clearSelectionBtn.disabled = false;
        enableLoopBtn.disabled = false;
        exportSelectionBtn.disabled = false;
        captureSelectionBtn.disabled = false;
        
    } else {
        selectedRangeDisplay.textContent = 'None';
        selectedRangeDisplay.className = 'info-value';
        exportReadyDisplay.textContent = 'No';
        exportReadyDisplay.className = 'info-value';
        
        clearSelectionBtn.disabled = true;
        enableLoopBtn.disabled = true;
        exportSelectionBtn.disabled = true;
        captureSelectionBtn.disabled = true;
    }
    
    // Update loop status
    if (isLooping) {
        loopStatusDisplay.textContent = 'Active';
        loopStatusDisplay.className = 'info-value active';
        enableLoopBtn.disabled = true;
        disableLoopBtn.disabled = false;
        enableLoopBtn.classList.remove('active');
        disableLoopBtn.classList.add('active');
    } else {
        loopStatusDisplay.textContent = 'Disabled';
        loopStatusDisplay.className = 'info-value';
        enableLoopBtn.disabled = false;
        disableLoopBtn.disabled = true;
        enableLoopBtn.classList.remove('active');
        disableLoopBtn.classList.remove('active');
    }
}

// Clear bar selection
function clearBarSelection() {
    console.log('ðŸ—‘ï¸ Clearing bar selection...');
    
    // Reset state
    barSelectionState.startBar = null;
    barSelectionState.endBar = null;
    barSelectionState.currentSelection = null;
    barSelectionState.selectionBounds = null;
    
    // Clear AlphaTab playback range
    if (api) {
        api.playbackRange = null;
        barSelectionState.isLooping = false;
    }
    
    // Remove visual selection
    removeVisualSelection();
    
    // Update UI
    updateSelectionUI();
    
    console.log('âœ… Bar selection cleared');
}

// Enable playback loop for selected range
function enablePlaybackLoop() {
    if (!api || !currentScore || barSelectionState.startBar === null || barSelectionState.endBar === null) {
        console.warn('âš ï¸ Cannot enable loop: API, score, or selection not ready');
        return;
    }
    
    try {
        console.log(`ðŸ”„ Enabling playback loop for bars ${barSelectionState.startBar + 1}-${barSelectionState.endBar + 1}`);
        
        // Calculate tick positions for the selected bars
        const startBarIndex = barSelectionState.startBar;
        const endBarIndex = barSelectionState.endBar;
        
        // Get the master bars
        const startMasterBar = currentScore.masterBars[startBarIndex];
        const endMasterBar = currentScore.masterBars[endBarIndex];
        
        if (!startMasterBar || !endMasterBar) {
            throw new Error('Could not find master bars for selection');
        }
        
        // Create playback range
        const playbackRange = new alphaTab.synth.PlaybackRange();
        playbackRange.startTick = startMasterBar.start;
        playbackRange.endTick = endMasterBar.start + endMasterBar.calculateDuration();
        
        // Apply to AlphaTab
        api.playbackRange = playbackRange;
        barSelectionState.isLooping = true;
        
        // Update UI
        updateSelectionUI();
        
        console.log('âœ… Playback loop enabled');
        console.log(`ðŸ“Š Loop range: ${playbackRange.startTick} - ${playbackRange.endTick} ticks`);
        
    } catch (error) {
        console.error('âŒ Failed to enable playback loop:', error);
        alert('Failed to enable playback loop. Please try again.');
    }
}

// Disable playback loop
function disablePlaybackLoop() {
    if (!api) {
        console.warn('âš ï¸ Cannot disable loop: API not ready');
        return;
    }
    
    console.log('â¹ï¸ Disabling playback loop...');
    
    // Clear AlphaTab playback range
    api.playbackRange = null;
    barSelectionState.isLooping = false;
    
    // Update UI
    updateSelectionUI();
    
    console.log('âœ… Playback loop disabled');
}

// Export selected bars using the new selection system
function exportSelectedBars() {
    if (!barSelectionState.selectionBounds) {
        console.warn('âš ï¸ No selection bounds available for export');
        alert('Please apply a bar selection first');
        return;
    }
    
    console.log('ðŸ“¤ Exporting selected bars...');
    
    // Update the export modal with the current selection
    const startBar = barSelectionState.startBar + 1; // Convert back to 1-based
    const endBar = barSelectionState.endBar + 1;
    
    // Set the export modal values
    document.getElementById('startBar').value = startBar;
    document.getElementById('endBar').value = endBar;
    
    // Open the export modal
    openExportModal();
}

// Capture selected area using screen capture API
async function captureSelectedArea() {
    if (!barSelectionState.selectionBounds) {
        console.warn('âš ï¸ No selection bounds available for capture');
        alert('Please apply a bar selection first');
        return;
    }
    
    console.log('ðŸ“¸ Capturing selected area...');
    
    try {
        // Check if screen capture is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            throw new Error('Screen capture not supported in this browser');
        }
        
        // Get the bounds of the AlphaTab container
        const alphaTabContainer = document.getElementById('alphaTab');
        const containerRect = alphaTabContainer.getBoundingClientRect();
        const selectionBounds = barSelectionState.selectionBounds.totalBounds;
        
        console.log('ðŸ“Š Capture bounds:', {
            container: containerRect,
            selection: selectionBounds
        });
        
        // For now, show the bounds information to the user
        const boundsInfo = `
Selection Bounds:
â€¢ Container: ${Math.round(containerRect.left)}, ${Math.round(containerRect.top)}, ${Math.round(containerRect.width)}Ã—${Math.round(containerRect.height)}
â€¢ Selection: ${Math.round(selectionBounds.x)}, ${Math.round(selectionBounds.y)}, ${Math.round(selectionBounds.width)}Ã—${Math.round(selectionBounds.height)}
â€¢ Bars: ${barSelectionState.startBar + 1}-${barSelectionState.endBar + 1}

These coordinates can be used with screen capture tools for precise cropping.
        `;
        
        alert(boundsInfo);
        
        // Copy bounds to clipboard
        const boundsData = {
            containerBounds: {
                x: Math.round(containerRect.left),
                y: Math.round(containerRect.top),
                width: Math.round(containerRect.width),
                height: Math.round(containerRect.height)
            },
            selectionBounds: {
                x: Math.round(selectionBounds.x),
                y: Math.round(selectionBounds.y),
                width: Math.round(selectionBounds.width),
                height: Math.round(selectionBounds.height)
            },
            barRange: {
                start: barSelectionState.startBar + 1,
                end: barSelectionState.endBar + 1
            }
        };
        
        await navigator.clipboard.writeText(JSON.stringify(boundsData, null, 2));
        console.log('ðŸ“‹ Bounds data copied to clipboard');
        
    } catch (error) {
        console.error('âŒ Screen capture failed:', error);
        alert(`Screen capture failed: ${error.message}`);
    }
}

// Update the score loaded event to store current score and enable export button
function updateScoreForExport(score) {
    currentScore = score;
    exportPngBtn.disabled = false;
    exportPngBtn.title = 'Export HTML';
}

// Helper function to render specific bar range
async function renderBarRange(startBar, endBar) {
    if (!api || !currentScore) {
        throw new Error('AlphaTab API or score not available');
    }
    
    console.log(`Rendering bar range: ${startBar + 1} to ${endBar + 1}`);
    
    // Check if we need to render a specific range or full score
    const totalBars = currentScore.masterBars ? currentScore.masterBars.length : 0;
    const isFullRange = startBar === 0 && endBar === (totalBars - 1);
    
    if (isFullRange) {
        console.log('Rendering full score (no bar range filtering needed)');
        // Just ensure the full score is rendered
        api.renderScore(api.score);
    } else {
        console.log('Rendering partial bar range - this will require custom implementation');
        // For now, render the full score and we'll crop during export
        // TODO: Implement actual bar range rendering
        api.renderScore(api.score);
    }
    
    // Reset rendering completion flag and wait for new render
    isRenderingComplete = false;
    await waitForRenderingComplete();
    
    return { isFullRange, totalBars };
}

// Event handler for when score is loaded
function onScoreLoaded(score) {
    console.log('ðŸŽµ Score loaded:', score);
    currentScore = score;
    
    // Update track info
    updateTrackInfo(score);
    
    // Populate bar dropdowns for export
    populateBarDropdowns(score);
    
    // Update bar selection system
    updateScoreForBarSelection(score);
    
    // Update export system
    updateScoreForExport(score);
    
    // Show controls
    document.getElementById('trackControls').style.display = 'block';
    document.getElementById('horizontalControls').style.display = 'flex';
}

// Force hide modal function
function forceHideModal() {
    // Implement your logic to hide the modal
    console.log('Modal hidden');
}

// Update the score loaded event to populate bar selection dropdowns
function updateScoreForBarSelection(score) {
    if (!score) return;
    
    // Show bar selection section
    barSelectionSection.style.display = 'block';
    
    // Populate bar selection dropdowns
    populateBarSelectionDropdowns(score);
    
    console.log('ðŸŽ¯ Bar selection updated for new score');
}

// Populate bar selection dropdowns
function populateBarSelectionDropdowns(score) {
    // Clear existing options
    selectionStartBar.innerHTML = '';
    selectionEndBar.innerHTML = '';
    
    // Get total number of bars
    let totalBars = 0;
    if (score.masterBars && score.masterBars.length > 0) {
        totalBars = score.masterBars.length;
    } else {
        // Fallback: estimate from first track
        const firstTrack = score.tracks[0];
        if (firstTrack && firstTrack.staves && firstTrack.staves[0] && firstTrack.staves[0].bars) {
            totalBars = firstTrack.staves[0].bars.length;
        }
    }
    
    if (totalBars === 0) {
        totalBars = 1;
    }
    
    // Populate dropdowns
    for (let i = 1; i <= totalBars; i++) {
        const startOption = document.createElement('option');
        startOption.value = i;
        startOption.textContent = `Bar ${i}`;
        selectionStartBar.appendChild(startOption);
        
        const endOption = document.createElement('option');
        endOption.value = i;
        endOption.textContent = `Bar ${i}`;
        selectionEndBar.appendChild(endOption);
    }
    
    // Set default selection (first 4 bars or all if less than 4)
    selectionStartBar.value = 1;
    selectionEndBar.value = Math.min(4, totalBars);
    
    console.log(`ðŸ“Š Bar selection dropdowns populated with ${totalBars} bars`);
}

// Populate bar dropdowns
function populateBarDropdowns(score) {
    // Clear existing options
    selectionStartBar.innerHTML = '';
    selectionEndBar.innerHTML = '';
    
    // Get total number of bars
    let totalBars = 0;
    if (score.masterBars && score.masterBars.length > 0) {
        totalBars = score.masterBars.length;
    } else {
        // Fallback: estimate from first track
        const firstTrack = score.tracks[0];
        if (firstTrack && firstTrack.staves && firstTrack.staves[0] && firstTrack.staves[0].bars) {
            totalBars = firstTrack.staves[0].bars.length;
        }
    }
    
    if (totalBars === 0) {
        totalBars = 1;
    }
    
    // Populate dropdowns
    for (let i = 1; i <= totalBars; i++) {
        const startOption = document.createElement('option');
        startOption.value = i;
        startOption.textContent = `Bar ${i}`;
        selectionStartBar.appendChild(startOption);
        
        const endOption = document.createElement('option');
        endOption.value = i;
        endOption.textContent = `Bar ${i}`;
        selectionEndBar.appendChild(endOption);
    }
    
    // Set default selection (first 4 bars or all if less than 4)
    selectionStartBar.value = 1;
    selectionEndBar.value = Math.min(4, totalBars);
    
    console.log(`ðŸ“Š Bar selection dropdowns populated with ${totalBars} bars`);
} 